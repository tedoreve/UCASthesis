\chapter{基于PLUTO软件包的超新星遗迹磁流体模拟程序编写}
\label{PLUTO}



\section{PLUTO软件简介}
\label{PLUTOintro}
PLUTO是一个有多国科研人员共同完成的流体模拟软件包，至今为止一直得到很好的维护，是进行天体
物理相关模拟的强大工具\citep{Mignone2007,Mignone2012}。
目前，软件只支持Linux/Unix平台运行，最基本的运行只依赖Python2、C、GNU make，几乎是每个
Linux/Unix平台发行版都会自带的。
而进一步的需求跟具体要求有关，要进行并行计算需要安装MPI library，要输出HDF5格式需要安装HDF5
library，要进行自适应网格(Adaptive Mesh Refinement, AMR)模拟需要安装C++、Fortran和
Chombo library，HDF5 library。
当然，如果要直接输出PNG格式图像，需要安装PNG library，但是我们很少这样做，因为输出数组
格式的二进制文件后可以直接用Python读取进行可视化，结果修改更灵活。

其主题文件目录结构包括：

\begin{enumerate}

    \item Config/：包含系统配置文件，软件要根据其中的内容读取依赖的代码的信息，比如系统是否
    已经安装C，HDF5 library等。这个文件夹中原始文件都是一些针对不同系统的模板，代码编译
    之前，需要根据模板自己编写适合自己系统的配置文件。

    \item Doc/：软件文档，包括pdf文档和html文档，两者内容相差不大，pdf文档更为全面，
    html文档更为直观，html文档还有一个好处是其中的代码可以直接复制用来测试。

    \item Lib/：额外需要的运行库的安装位置。比如要进行AMR模拟，需要安装Chombo库，那么
    相应的库最好安在这个，如果安在别的地方需要额外的路径配置。

    \item Src/：程序主目录，除了初始条件设定部分，所有进行具体运算的代码都在这个目录。

    \item Tools/：有用的小工具。我们主要使用其中的pyPLUTO进行可视化。

    \item Test$\_$Problems/：包含各种各样使用PLUTO的例子。这些事例对于初学者非常友好，根据
    文档可直接运行，对于了解整个软件的使用很有帮助。

\end{enumerate}

而实际进行模拟时基本不需要修改这其中的文件，可以直接在自己新建的文件夹中操作，在程序运行
时设置好环境变量就行。

PLUTO本身可进行的模拟种类非常多，而本章节只以超新星遗迹模拟为例详细介绍MHD模拟方法，
而可视化方法中只介绍Python的使用与优化，更多的内容请见PLUTO的Doc目录中的官方文档。

\section{PLUTO基本使用}
\label{PLUTOuse}
具体下载安装请见http://plutocode.ph.unito.it，而在文档的Quick Start部分有简要的路径
配置，我们只介绍文件编写和运行。
软件安装、配置完成后，我们需要新建工作目录，比如目录SNR/，而要进行一个完整模拟，这个目录
中至少需要三个文件definition.h、init.c、pluto.ini。
其中definition.h主要定义需要的物理及计算方式，init.c定义初始条件，pluto.ini定义需要的
参数，三者名称都可以改变，但是个人建议使用此默认命名，之后交流比较方便。

而大概使用步骤如下：
\begin{enumerate}

    \item definition.h编写完成后，使用python \$PLUTO$\_$DIR/setup.py，确认使用的参数，然后选择自己
    在Config/中设置好的配置文件，如果使用Ubuntu等Linux系列平台进行非并行运算，选择默认的
    Linux.gcc.defs即可。

    \item init.c编写完成后，使用make编译程序，程序会根据definition.h中设置的参数进行编译，默认会
    生成名为pluto的可执行程序。

    \item pluto.ini编写完成后，使用./pluto运行程序，pluto程序会从pluto.ini中读取相应的数值，然后
    开始运行，运行结果与具体参数设置有关。

\end{enumerate}
我用于SNR W51C模拟的相应代码列在附录~\ref{Basic}中，更多使用的例子可在我个人的代码库
https://github.com/tedoreve/PLUTO中找到。

\subsection{definition.h的编写}
\subsubsection{基本选项}

PHYSICS选项，定义需要的物理，可选HD(流体)、MHD(磁流体)、RHD(相对论流体)、
RMHD(相对论磁流体)，我们主要介绍磁流体模拟，选MHD即可。
MHD模拟内核主要是通过解质量守恒、动量守恒、能量守恒和磁通守恒方程获得结果，需要注意的是，
这里的压强和能量包括磁压和磁能，要根据物态方程获得温度等信息时，要记得与温度有关的压强是
要扣除磁压的。

DIMENSIONS选项，定义模拟的空间维度，可选1、2、3，如果要进行三维模拟，选3即可。
COMPONENTS选项，设置矢量的分量个数，通常三维空间的矢量有三个分量，但有时为了计算方便也
可以约简其中一个分量，比如模拟恒星盘的形成时，大部分物质都在二维平面上运动，但其运动也会
影响第三维上的动量等参数。通常我们取DIMENSIONS=COMPONENTS即可。

GEOMETRY选项，设置使用的坐标系，可选CARTESIAN(笛卡尔)、CYLINDR- AICAL(柱坐标)、
POLAR(极坐标)、SPHERICAL(球坐标)。
不同的坐标对不同的积分方式兼容性不同，一半情况下，选用笛卡尔坐标系即可。

BODY$\_$FORCE选项，可选POTENTIAL(标量势)、VECTOR(矢量引力)、POTENTIAL+VECTOR
(标量+矢量描述)。
标量势计算方便，但是在不够准确，尤其是引力场较复杂的时候。矢量引力计算时间长很多，但更准
确。我个人没有遇到过必须两者都考虑的情况，不过测试时间与只考虑矢量引力差不太多。

COOLING选项，可选POWER$\_$LAW、TABULATED、SNEq、H2$\_$COOL、MINEq。
光学薄的情况下，韧致辐射等过程导致的辐射能量损失也会影响MHD模拟结果，这个过程与当地密度、
温度、各种成分的丰度有关，尤其是丰度部分很难估算，因而模型很多。
POWER$\_$LAW模型是假设辐射损失与$\rho^2T^{\alpha}$成正比，其中$\rho$为密度，T为温度，
$\alpha$为幂律指数。
TABULATED模型是假设辐射损失与$n^2\Lambda(T)$成正比，其中$n$为数密度，$\Lambda$为冷却
方程，而冷却方程又有很多种\citep{2017RMxAA..53..385F}。
SNEq模型主要考虑了中性氢原子的辐射，同时也将16种最常见的谱线辐射考虑在内，比如Ly$\alpha$、
H$\alpha$、HeI、CI、OII、FeII等。
H2$\_$COOL模型在SNEq模型的基础上考虑了分子氢和离子氢，此外，可根据需要加入一氧化碳(CO)、
羟基(OH)和水分子(H$_2$O)等辐射贡献。
MINEq模型在SNEq模型的基础上考虑了更过谱线辐射，总共达到28种，不过对分子类辐射贡献的计算
支持不好。
超新星遗迹的模拟中，早期自由膨胀相和绝热膨胀相辐射耗散相对总能量很小，对整体模拟结果影响
不大，随着年龄变老，辐射能量越来越大，直到辐射相已经不可忽略。

RECONSTRUCTION选项，可选FLAT、LINEAR、WENO3、LimO3、PARABOLIC，是五种重构方法。
重构是模拟中的一个重要过程，随着时间变化，每一个步长间隔都需要重构一次整个模拟图像。
更好的重构方法可保证模拟结果更加准确，通常使用默认的LINEAR方法即可，如果速度太慢可尝试
FLAT方法，如果设定初始物理参数很极端而结果明显存在问题，可尝试其它三种方法。

TIME$\_$STEPPING选项，可选EULER、RK2、RK3、CHARACTERISTIC$\_$TRACING、HANCOCK，是五种
时间推演方法。
要知道，布置邻近格点会影响一个格点下一步的数值，可能更远的格点也会影响，如果步长过长，
会有过多格点影响到一个格点的数值，计算结果容易有偏差，当然，步长过短会导致运行过慢。
所以我们要选择合适的推演方法，通常在超新星遗迹模拟中选择RK2即可。
此外，我们可以通过设定Courant-Friedrichs-Lewy(CFL)数来控制具体方法，具体设定不只与
TIME$\_$STEPPING有关，还要考虑所选维度及是否使用DIMENSIONAL$\_$SPLITTING。

DIMENSIONAL$\_$SPLITTING选项，可选YES或者NO。
有时候，虽然我们模拟的是多维的图像，但是不同维度的影响并不会耦合，结果就是我们可以当作
在不同方向上都做一维的模拟，这时候可选YES。
而超新星遗迹的模拟每个方向上的演化都是互相影响的，所以必须选NO，不然结果很容易出错。

NTRACER选项，这其实是一个扩展选项，最大数目为4。
通常对于特定的PHYSICS守恒量都是一定的，如果要增加新的守恒量就要添加在这里，比如加入
氢原子数目守恒。

USER$\_$DEF$\_$PARAMETERS选项，输入需要的自定义参数数目，最大31。
设置初始条件时需要很多参数，比如超新星爆发能量、前身星质量、介质平均密度等，将来调参调的
就是这些，而这里只是提前设置好参数数目。

\subsubsection{物理依赖选项}
BACKGROUND$\_$FIELD选项，如果设置为YES，意味着设置磁场包含背景的静态场和随时变化的磁场。
超新星遗迹当中的磁场并不需要分成分，都是随时变化的，因而设为NO即可。
可是，如果需要考虑脉冲星风云中几乎保持不变的中子星磁场，就要设置为YES。

DIVB$\_$CONTROL选项，可选NO、EIGHT$\_$WAVES、DIV$\_$CLEANING、CONSTRAINED$\_$TRANSPORT。
数值方法无法保证磁场无源，我们需要强制控制其散度为零。
超新星遗迹模拟中使用EIGHT$\_$WAVES即可。

EOS选项，选择需要的物态方程，可选IDEAL、ISOTHERMAL、PVTE$\_$LAW、TAUB。
超新星遗迹的模拟中，使用IDEAL即可。

ENTROPY$\_$SWITCH选项，可选NO、SELECTIVE、ALWAYS、CHOMBO$\_$REGRID。
保证熵增原则，只对EOS为IDEAL和TAUB适用，不过在超新星遗迹模拟中影响不大，设为NO。

RESISTIVITY、VISCOSITY、THERMAL$\_$CONDUCTION选项，可选NO、EXPLICIT、SUPER$\_$TIME$\_$STEPPING，
控制电磁阻力、粘滞相应、热传导影响，都是有关耗散效应，在年轻超新星遗迹模拟中影响不大，
一般设为NO即可，而对老年超新星遗迹需要具体分析。
我们在章节~\ref{SW}有讨论热传导的影响，最终结论只是对星风演化影响很大。

ROTATING$\_$FRAME选项，使用CYLINDRAICAL(柱坐标)、POLAR(极坐标)、SPHERICAL(球坐标)
时建议选YES。

\subsubsection{自定义参数和常数}
自定义参数即是根据USER$\_$DEF$\_$PARAMETERS选项中设置的数目在这里列出相应数量的参数，而其
具体数值主要在pluto.ini中给出，然后由init.c中写的初始条件融入到整个程序里。

而自定义常数主要是一些只在特定模拟中有意义的数值，比如各种物理常数，同时，编写init.c时需要
控制的条件也可以写在这里，比如设置自定义参数ADD$\_$TURBULENCE为YES或者NO，而init.c中有
相应的条件语句从而实现不同的功能。
其实大部分物理上的常数已经包含在/Src/pluto.h中，在写init.c时直接调用即可，不过这一部分有
一个重要的功能就是设定单位制。
我们知道常用的国际单位制、CGS单位制要表达一些比较大的数值时需要科学记数法，可是在进行
模拟时这种记数法是没用的，当数值非常大或者非常小，超过给其分配的计算空间时，会导致计算溢出，
最终模拟结果肯定会有问题。
所以，我们通常需要自己创造一套适合自己模拟的单位制。
通常制定一套单位制需要三个独立基本物理量的单位即可，其它单位可以由此推出，通常大家都选用
长度、质量、时间，类似CGS单位制。
天文单位中经常过大或过小，而PLUTO又是一个为天文服务的模拟软件，虽然其主程序默认CGS单位制，
实际模板选用的基本物理量单位是：1 $m_p g/cm^3$(密度)、1 AU(长度)、1 \kms(速度)。
这个单位制对于模拟恒星盘、太阳风等非常合适，但是对于模拟超新星遗迹就捉襟见肘了。
所以，在我们模拟遗迹时，选用的基本物理量单位是：1 $m_p g/cm^3$(密度)、1 pc(长度)、
10000 \kms(速度)。
其它一些需要注意的事情在MHD模拟中无需考虑，比如要使用相对论模块，速度单位必须是光速。

而实际物理研究时，我们通常使用CGS单位制，要将模拟结果转化过来，需要一些计算。
最直观的，单位时间即单位长度除以单位速度，
$t_0 = L_0/v_0 = 1 pc/10000$ \kms $= 3.09\times10^9 s = 98$年。
下面列出常用参量计算，无下标的即模拟结果中的实际数值，下标为0的即是用我们所选三个基本单位
计算的用在模拟中的其它相应单位，下标为cgs的即在CGS单位制中的实际数值：

\begin{equation}
  \begin{aligned}
    \rho = \dfrac{\rho_{cgs}}{\rho_0} ,   \
    v = \dfrac{v_{cgs}}{v_0} ,   \
    p= \dfrac{p_{cgs}}{p_0v_0^2} ,   \
    B = \dfrac{B_{cgs}}{\sqrt{4\pi\rho_0v_0^2}} ,   \
  \end{aligned}
\end{equation}
更多转换请见附录~\ref{Codeu}。

\subsubsection{其它经常使用的选项}
上面三部分的选项，在第一步运行setup.py时还有一次更改的机会，而这部分的选项只能在definitions.h
里修改。

INITIAL$\_$SMOOTHING选项，设置为YES可以用来数值平滑起伏很大的区域，主要用来消除与网格化
不匹配的边界效应，比如笛卡尔坐标系中的球形。
然而，开启这个选项会大大降低程序运行速度，有时候反而会平滑掉真实的小尺度结构，不建议使用。
如果最终结果需要平滑，最好直接自己手动编写程序优化图像。

WARNING$\_$MESSAGES选项，设置为YES可以使得程序遇到问题后打出提示。
实际测试中发现，其实大部分问题都不影响程序运行，这个选项打出的问题只是警告(warning)，
并不是错误(error)。
问题是，有时警告太多，将真正有用的运行信息遮挡，如果选择了PRINT$\_$TO$\_$FILE选项，输出的文件
会非常大，个人不建议使用。

PRINT$\_$TO$\_$FILE选项，顾名思义，设置为YES时，程序运行时本来打印在命令行里的信息会打印
到pluto.log文件中。

INTERNAL$\_$BOUNDARY选项，设置为YES时，可以在init.c中的UserDefBoundary()函数中定义内
边界，可以使得边界内的参数在模拟过程中保持不变。
这个选项在模拟星风、喷流等持续存在的现象时非常有用。

SHOCK$\_$FLATTENING选项，可选NO、ONED、MULTID。
因为激波区域参数起伏较大，有时会导致程序出错、卡死，为了减少这种起伏保证程序足够稳定，
可以使用这一选项，平滑激波区域各种参数。
ONED是一维平滑，MULTID是多维平滑，效果比一维要好，不过类似于INITIAL$\_$SMOOTHING，这个
选项会大大减慢运行速度，尤其是多维平滑，几乎不可用。
建议在遇到比较复杂的激波结构或者模拟出现莫名其妙的错误时使用，单个超新星遗迹的模拟不太需要。

CHAR$\_$LIMITING选项，选择YES以使得重构时直接计算守恒量等特征变量，而不是计算速度、密度、
磁场等初始变量。
这个方式也是很耗时，相当于每一步计算都增加了一些计算量，但是相对来说在参数变化较大甚至
明显不连续以至于平滑都无法做到的地方很有效，此外对熵增原则也可以更好地保证。
不过在超新星遗迹模拟中并不是很必要。

LIMITER选项，可选项很多，主要是RECONSTRUCTION中选择LINEAR时才可使用，主要是对这种重构
方式的各种调试，如果模拟结果莫名其妙，而且其它任何地方都找不到错误时，可以尝试调试一下。
个人只遇到过一次必须改变这一选项的情况，请酌情使用。

ASSIGN$\_$VECTOR$\_$POTENTIAL选项，设置为YES后，磁场成分初始化方式改变，可以保证磁场无源。
只在使用特殊算法时有用，一般情况下使用DIVB$\_$CONTROL足够。

\subsubsection{makefile文件的设置}
通常，使用python \$PLUTO$\_$DIR/setup.py获得的makefile文件就是最合适的配置了。
如果还有其它需求，最好在/Config目录中的.defs文件中修改，这样以后使用相同配置时也有现成
的模板，比较方便。
而在这里可能需要修改的主要有是否使用并行MPI、是否支持HDF5存储格式，以及是否要在编译时
链接自己写的其他的源码。
如果要修改/Src中的源文件，直接将相应文件拷入工作目录修改即可，程序会先自动搜索工作目录，
不需要在makefile中设置。
虽然，在这里可以加入PNG包的支持以方便程序直接输出图像，可是直接输出图像通常效果较差，
而且灵活度不高，不如输出数据，以后自己进行可视化。
所以，通常我们不会使用PNG包。

\subsection{init.c的编写}
这个文件主要用来具体定义需要模拟的物理问题，主要包括以下几个函数：

\begin{enumerate}

    \item Init()：设置每一个格点的参数值，主要有磁场、密度、压强、速度等。

    \item UserDefBoundary()：用来定义边界条件，比如设为流体运动到边界是自然流出还是会
    反射。如果在definition.h中开启了INTERNAL$\_$BOUNDARY选项，具体内边界的性质就要在
    这里定义。

    \item BodyForceVector()、BodyForcePotential()：定义引力场的矢量分布或者引力势分
    布。根据开启的BODY$\_$FORCE选项修改这一部分内容。

    \item BackgroundField()：用来设置背景静态磁场。如果开启BACKGROUND$\_$FIELD选项，
    需要在这里定义具体的磁场。

    \item Analysis()：程序运行时进行实时的分析，个人很少用到。如果程序运行时间很长，
    可以设定没过一段时间输出一次结果，直接分析输出数据手动分析程序是否正确运行就好，
    不太需要这个实时分析模块。

\end{enumerate}
在超新星遗迹的模拟中，我们主要需要关注前两点，而在某些情况下考虑引力也是一个有趣的选择，
所以我们也会介绍第三点。
其它函数的使用可参照官方文档。

\subsubsection{Init()的编写}
Init()函数的初始化形式为void Init (double *us, double x1, double x2, double x3)，
其中us可认为是一个大型数组，里面包含了所有运算中需要的初始变量，比如密度即是us[RHO]，
速度沿x1轴的分量是us[VX1]。
要注意的是，矢量成分在不同坐标系下标识不同，比如速度在柱坐标系下，沿R轴方向分量为us[iVR]。
而后面的x1、x2、x3是相应的坐标。

通常，模拟得到的是压强、密度等信息，而我们有时需要计算温度，比如要估计X射线的辐射时，而
计算公式通常为：

\begin{equation}
  \begin{aligned}
    T = \dfrac{p}{\rho}\dfrac{\mu m_{\mu}v_0^2}{k_B}=K\mu\dfrac{p}{\rho} ,   \
  \end{aligned}
\end{equation}
其中$m_{\mu}$是原子质量单位，$\mu$是平均原子权重，$p$和$\rho$是程序中实际用到的无量纲
参数。
因为我们要得到带量纲的实际参数，因而要乘上相应的单位，而程序中压强与实际压强相差$v_0^2$，
所以公式中也要加入，所以最终看到的转换因子$K$中也包含$v_0^2$。
而$\mu$可以通过调用MeanMolecularWeight()获得，这个函数可以根据选择的冷却方程具体计算
$\mu$的值，因为选定了冷却方程也就是选定了要使用的各种原子、分子的比例。
此外，程序里运行得出的压强us[BX1]等都指的是热压，如果要考虑磁场对压强的贡献，可以通过
计算$\beta_b=2p/B^2$，估计热压与磁压的比例。
这里因为单位制不一样，所以这个比例的计算公式与章节~\ref{TheoryMHD}中的相差一个常数。

这部分中另外一个重要的编写方式就是直接通过读取外部文件设置初始条件。
比如我们对一个超新星遗迹进行了CO的观测，然后希望以CO图像为准构建初始介质分布，那就直接
读入后经过适当的转换即可。
具体操作主要是首先构建网格参数，文件名类似于grid.out，然后使用InputDataSet()函数读入。
接着导入参数在每一个格点的值，文件名类似于data.0010.dbl，然后使用InputDataRead()函数
读入。
然后使用InputDataInterpolate()函数使得导入的数值生效。
利用这种思路，一个人工生成初始条件的程序请见附录~\ref{Codeb}。

\subsubsection{UserDefBoundary()的编写}
UserDefBoundary()函数的初始化形式为
void UserDefBoundary (const Data *d, RBox *box, int side, Grid *grid)，
其中*d用于给制定边界赋值，*box用于给鬼区制定规则，side用于指定具体的边界，而*grid用于
设置网格结构。
使用这个函数需要在pluto.ini中定义大概的边界条件，然后由这个函数来具体实现。

如果在definition.h中开启了INTERNAL$\_$BOUNDARY选项，相应的内边界区域在UserDefBoundary()
中定义为side=0区域。
而如果想要设定随时间变化其中变量却不变的内边界，需要额外设定FLAG$\_$INTERNAL$\_$BOUNDARY。

\subsubsection{引力部分的编写}
引力部分主要有两种选择，用标量场引力势来表示和用矢量场引力加速度来表示。
当然，可以两者结合描述，但是大部分情况下用一种描述即可。
需要注意的是，这里表示的引力是不随时间变化的，类似于一个背景场。

标量场的描述函数为BodyForcePotential()，矢量场的描述函数为BodyForceVector()，二者
在MHD模拟中并无不同，只是BodyForceVector()在我测试用的代码中速度稍慢。
而实际上，在与同行交流时有人提到，有些情况下反而BodyForceVector()要快一些。
虽说这两个函数其实不局限于引力，但是天体物理模拟中在大尺度需要考虑的力基本只有这一种。

\subsection{pluto.ini的编写}
根据definition.h和init.c编译完成的程序启动后，首先会读取pluto.ini中的参数，然后开始
构建初始条件进行真正的模拟。
这个文件一共包含八个不同的设置区域，除了最后一个，具体的设置格式限制比较死，一半情况下
最好使用已有模板，我们只调整数值即可。
程序中如果遇到错误，首先要检查这个文件，然后是init.c，最后检查description.h和.defs文件。

首先是[grid]模块，主要用于设置网格的参数，包括鬼区数、网格真实尺度、格点数、网格类型。
其中网格类型主要用于提高特定区域的格点数，类似于提高分辨率，所以如果使用AMR技术，网格
类型并不重要，一般使用均匀网格即可。

[Chombo Refinement]模块，启用AMR时需要设置这一模块，主要设置精制的层级、网格、不同层级
间的精制的程度，更多内容见章节~\ref{PLUTOmore}。

[Time]模块，用于设置时间步长相关的参数，这里我们可以设置总共模拟的时间以及初始的时间步长。
可是，初始的步长有时候并不能保证是最适合的，程序会根据实际运行情况自动调整每一步的步长。
而具体每一步怎么调，也受到这里所使用的其它参数的控制。

[Solver]模块，用于选择流计算的黎曼解方法。
守恒方程中，每一个格点参数随时间变化是容易给出的，可是具体流动方式要用黎曼解具体处理。
越精确的处理方法越容易出错，通常选择hll方法就行。

[Boundary]模块，用于设置边界条件。
设为userdef可与init.c中的UserDefBoundary()结合使用。
要注意的是，即使是二维的程序，也要设置三维边界条件，只是不起作用，不然报错。

[Static Grid Output]模块，不使用AMR时的数据输出设置。
主要用于设置数据输出格式、输出频率和输出目录，此外可以自己添加需要输出的变量。

[Chombo HDF5 output]模块，使用AMR时的数据输出设置。
类似于静态网格输出模块，不过输出格式与输出变量都是固定的，无法更改。

[Parameters]模块，自定义参数设置。
这一模块就是在definition.h的USER$\_$DE- F$\_$PARAMETERS选项中提到的参数，具体在这里赋值，
然后在init.c中通过g$\_$inputParam[]函数赋值给相应的变量用于初始条件的构建。
只有这一模块是真正与具体要解决的物理问题相关，所谓的调参大部分时间都是在调这一部分。

\section{PLUTO进阶使用}
\label{PLUTOmore}
对于低分辨率、短时间的天体物理模拟，PLUTO的基本模块就足够了。
如果模拟需要的分辨率很高，比如研究超新星遗迹激波加速区上下游的磁场放大、磁压比例等，或者
模拟需要很长时间，比如研究星风演化百万年、千万年对周围介质的影响，就需要很大的计算量，
必须在高性能计算集群上进行并行运算。

此外，提高分辨率的方法通常是增加格点数，可是这样有时候会造成资源浪费。
我们通常只对某个区域非常关注，需要很高分辨率，而其它区域分辨率很低也无所谓。
如果对网格均匀增加格点数，不需要很高分辨率的地方也有了高分辨率，占用更多内存和算力，有
时候导致项目延期严重。
对于这种情况，使用AMR技术是一个非常好的选择。
使用这种技术之后，我们可以对关注的区域使用非常高的分辨率，这样能得到更多有价值的成果。
这其实仍旧非常耗时，需要使用并行计算。
只是占用同样的资源，得到了好得多的效果。

此外，虽然PLUTO本身提供了很好的可视化工具，可是具体操作仍旧比较复杂，而且其提供的工具
仍然不能满足一些需求，所以本章我们也会介绍一些可视化方式。

\subsection{并行计算与自适应网格}
并行计算首先需要在使用python \$PLUTO$\_$DIR/setup.py时，最后选择合适的并行配置文件。
然后系统必须安装并行编译软件，并确保相应依赖完整。
通常，我们需要在计算集群上运行并行计算，这时候要根据集群管理员提供的信息进行配置。
这里遇到的问题通常是提交任务时对队列的限制不清楚，导致队列提交失败。
更复杂的问题是，偶尔某个节点会出现问题，比如与其它节点通信不畅，队列管理系统却
不会提示，会出现莫名奇妙的程序中断。
这种时候可以先在一个节点运行程序，然后逐渐增加节点数目。

加入了自适应网格的并行计算经常出现节点通信不畅，个人使用过三个集群都出现过类似情况。
这种情况可能不是节点问题，而是AMR的参数设置过于苛刻，调整参数降低分辨率是个不错的选择。

要使用AMR技术，必须要安装HDF5数据格式支持。
HDF5支持分为非并行和并行，如果都要用的话，就都要安装。
而安装AMR的时候需要首先安装Chombo包，注意，PLUTO自带一个Chombo的补丁，需要将其覆盖
相应的Chombo包，才能用于PLUTO。
在集群上安装编译库文件时偶尔会遇到权限不足的情况，这时候使用chmod命令提升相应目录权限即
可，不需要全局权限。
使用AMR的模拟不一定要并行计算，但通常AMR非常耗时，并行计算是比较好的选择。

\subsection{数据可视化}
PLUTO自带多种语言的可视化接口，本章只介绍Python接口pyPLUTO。
pyPLUTO安装成功后，有两种使用方法，一种是在Python脚本中直接编写可视化代码，另一种是在
数据所在目录下直接键入GUI$\_$pyPLUTO.py使用交互界面。
通常交互界面只能用于程序调试，更可靠的可用于在文章中发表的图片必须要通过脚本编写获得。
不过，这个接口只支持画普通的一维、二维数据，而实际模拟结果经常是三维，所以必须要经过
切片处理。
如果要直接呈现三维模拟，需要使用一个名叫Mayavi的Python包，结合pyPLUTO进行三维投影、
动画制作，示例代码见附件~\ref{Mayavi}。

此外，有时我们需要将模拟结果转化为可观测的光学结果，通过进行一些假设，可以进行多波段
的SED转换，这要求我们对每一个格点都做一个SED，非常耗时。
好在，Python提供与C语言交互使用的并行计算包mpi4py，通过并行计算进行可视化，帮助我们
更快检验结果，提高调参效率，示例代码见附件~\ref{mpi4py}。
